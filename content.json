[{"title":"HTMLCSS网页设计学习笔记(2)","date":"2021-09-22T12:14:57.420Z","path":"posts/bc8fbd83.html","text":"第二部分的小节CSS篇。 span标签表示将文字包裹起来的一个容器。div，通用容器。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div style=\"color: #555;margin: auto;width: 100px;\"&gt; &lt;p style=\"text-align: center;\"&gt; &lt;span style=\"background-color: gray;color: white;font-size: 24px;\"&gt;边城&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;b&gt;在川湘交界的茶峒附近&lt;/b&gt; &lt;!-- b标签加粗 --&gt; &lt;span style=\"color: #41A863;\"&gt; 小溪白塔旁边，住着主人公翠翠和她爷爷老船夫。 茶峒城里有个船总叫顺顺，他有两个儿子， &lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;b&gt;老大叫天保，老二叫傩送。&lt;/b&gt; 端午节翠翠去看龙舟赛，偶然相遇相貌英俊的青年水手傩（nuó）送， 傩送在翠翠的心里留下了深刻的印象。 &lt;/p&gt; &lt;p&gt; 同时，傩送的兄长天保也喜欢上了翠翠，并提前托媒人提了亲。 天保告诉傩送一年前他就爱上了翠翠， 而傩送告诉天保他两年前就爱上了翠翠，天保听了后也吃了一惊。 &lt;/p&gt; &lt;p&gt; 然而此时，当地的团总以新磨坊为陪嫁，想把女儿许配给傩送。 而傩送宁肯继承一条破船也要与翠翠成婚。 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; div容器特点，默认宽度100%，高度0。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html style=\"background-color: #ddd;\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; &lt;/style&gt; &lt;/head&gt; &lt;body style=\"margin: 0;\"&gt; &lt;!-- 让边框去除 --&gt; &lt;div id=\"banner\"&gt; &lt;img src=\"img/QQ图片20210922204422.png\" style=\"width: 100%;\"&gt; &lt;/div&gt; &lt;div id=\"navigation\" style=\"height: 80px;line-height: 80px;text-align: center;background-color: white;\"&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;首页&lt;/a&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;关于王力&lt;/a&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;产品世界&lt;/a&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;新闻中心&lt;/a&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;网络事件&lt;/a&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;联系我们&lt;/a&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;关于我们&lt;/a&gt; &lt;a href=\"0\" style=\"text-decoration: none;color: black;margin: 0 15;\"&gt;网络新闻&lt;/a&gt; &lt;/div&gt; &lt;div id=\" bottom\" style=\"height: 40x;line-height: 40px;text-align: center;font-size: 14px;color: gray;\"&gt; 版权所有:浙江王力门业有限公司 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 内部样式，样式选择器 ID选择器，使用#号。标签选择器div。类别选择器.nav。*通用选择器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; html&#123; background-color: #ddd; &#125; body&#123; margin: 0; &#125; #navigation&#123; height: 80px;line-height: 80px;text-align: center;background-color: white; &#125; #bottom&#123; height: 40px;line-height: 40px;text-align: center;font-size: 14px;color: gray; &#125; .nav&#123; text-decoration: none;color: black;margin: 0 15; &#125; #banner img&#123; style=\"width: 100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 让边框去除 --&gt; &lt;div id=\"banner\"&gt; &lt;img src=\"img/QQ图片20210922204422.png\"&gt; &lt;/div&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"0\" class=\"nav\"&gt;首页&lt;/a&gt; &lt;a href=\"0\" class=\"nav\"&gt;关于王力&lt;/a&gt; &lt;a href=\"0\" class=\"nav\"&gt;产品世界&lt;/a&gt; &lt;a href=\"0\" class=\"nav\"&gt;新闻中心&lt;/a&gt; &lt;a href=\"0\" class=\"nav\"&gt;网络事件&lt;/a&gt; &lt;a href=\"0\" class=\"nav\"&gt;联系我们&lt;/a&gt; &lt;a href=\"0\" class=\"nav\"&gt;关于我们&lt;/a&gt; &lt;a href=\"0\" class=\"nav\"&gt;网络新闻&lt;/a&gt; &lt;/div&gt; &lt;div id=\"bottom\"&gt; 版权所有:浙江王力门业有限公司 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 样式表层叠 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #navigation&#123; text-align: center; &#125; #navigation .last&#123; border: none; &#125; .item&#123; text-decoration: none; color: black; border-right: solid 1px #808080; padding: 0 15px;/* 内边距填充 */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"navigation\"&gt; &lt;a href=\"0\" class=\"item\"&gt;首页&lt;/a&gt; &lt;a href=\"0\" class=\"item\"&gt;办公家居&lt;/a&gt; &lt;a href=\"0\" class=\"item\"&gt;数码科技&lt;/a&gt; &lt;a href=\"0\" class=\"item\"&gt;母婴&lt;/a&gt; &lt;a href=\"0\" class=\"item\"&gt;团购&lt;/a&gt; &lt;a href=\"0\" class=\"item last\" style=\"border: none;\"&gt;秒杀活动&lt;/a&gt; &lt;!-- 行内样式表优先级高 --&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; css优先级 行内样式》id选择器》类选择器》标签选择器》通用选择器 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; #p1&#123; color: blue; &#125; *&#123; color: orange; &#125; .pp&#123; color: green; &#125; p&#123; color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"pp\" id=\"p1\" style=\"color: slateblue;\"&gt; 猜猜我是什么颜色 &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 字体样式 1234567891011colorfont-family 字体样式font-sizefont-weight:bold 加粗font-style:italic 倾斜text-indent 首行缩进text-align: centerline-height 行高height:100px;background-color:gray;line-height:100px 垂直居中行高与高度一致使文字垂直方向居中text-decoration:underline 下划线 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; html,body&#123; margin: 0; height: 100%; &#125; body&#123; background-image: url(../002新闻/img/1.png); background-repeat: no-repeat; background-position: center center; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 元素浮动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; .green &#123; width: 100px; height: 100px; background-color: green; float: left; &#125; .red &#123; width: 200px; height: 150px; background-color: red; &#125; .a &#123; width: 20%; height: 200px; background-color: green; &#125; .b &#123; width: 60%; height: 200px; background-color: red; &#125; .c &#123; width: 20%; height: 200px; background-color: blue; &#125; .a, .b, .c &#123; float: left; &#125; .hh &#123; width: 100%; height: 360px; background-color: black; &#125; .outer &#123; height: 200px; /* 若不设置该属性 */ overflow: auto; clear: left;/* 当前元素不会受到left right both元素的影响 */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;文字环绕效果&lt;/p&gt; &lt;div class=\"green\"&gt;&lt;/div&gt; &lt;div class=\"red\"&gt;&lt;/div&gt; &lt;p&gt;横向排版&lt;/p&gt; &lt;div class=\"outer\"&gt; &lt;div class=\"a\"&gt;&lt;/div&gt; &lt;div class=\"b\"&gt;&lt;/div&gt; &lt;div class=\"c\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 为了不影响后续元素的排列，浮动要包含于父容器内 --&gt; &lt;div class=\"hh\"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 元素边距margin 1234*&#123; margin: 0;&#125;填充padding（内边距）随着填充增加，元素会被撑大。 表单补充 1234567891011121314&lt;input type=\"text\" value=\"默认值,此处文本框内输入内容并不会消失\" placeholder=\"请输入您的姓名\"&gt;用placehodler实现输入内容后提示内容消失下拉菜单&lt;select&gt; &lt;option&gt;&lt;/option&gt; &lt;option&gt;&lt;/option&gt; &lt;option&gt;&lt;/option&gt;&lt;/select&gt;多行文本框&lt;textarea cols=“50”代表一行能放50个字符 rows=\"5\"&gt; 内部可以被填入内容&lt;/textarea&gt; css文件的引用 12&lt;link rel&#x3D;&quot;stylesheet&quot; typye&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;填写路径&quot;&gt;rel定义关联","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"HTML","slug":"HTML","permalink":"https://nari2021.github.io/my-blog/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://nari2021.github.io/my-blog/tags/CSS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"HTMLCSS网页设计学习笔记(1)","date":"2021-09-19T11:39:03.000Z","path":"posts/97a2ee40.html","text":"web前端的第一部分：HTML+CSS 编程软件Hbuilderx 第一个helloworld，使用的内置浏览器运行 12345678910&lt;!DOCTYPE html&gt; # 告诉编译器这个是用html5（必须）&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好 helloworld&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617 &lt;body&gt; &lt;h1&gt;你好 helloworld&lt;/h1&gt; &lt;h3&gt;你好 helloworld&lt;/h3&gt; &lt;h6&gt;你好 helloworld&lt;/h6&gt; &lt;h4&gt;你好 helloworld&lt;/h4&gt; 标题等级h1-h6 &lt;i&gt;2021.9.19&lt;/i&gt; &lt;hr /&gt; // i表示斜体 // &lt;hr&gt; 横的分割线 &lt;p&gt;aaaaa&lt;/p&gt; &lt;br&gt;bbbbb // p 新段落 br换行都是单独标签 b加粗 // 源代码中的空格用&amp;nbsp;表示 &lt;/body&gt;&lt;/html&gt; 插入图片 1&lt;img src &#x3D; &quot;&quot;&gt; 无序列表 1&lt;ul&gt;（unordered list）&lt;&#x2F;ul&gt; 有序列表 1&lt;ol&gt; &lt;&#x2F;ol&gt; ，列表内项目用记述。 超链接语法 1&lt;a href &#x3D; &quot;跳转地址&quot;&gt; 标题 &lt;&#x2F;a&gt; 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;百度新闻列表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;科技&lt;img src=\"img/1.png\"&gt;&lt;/h1&gt; &lt;hr /&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"http://www.baidu.com\"&gt;中子星内比例&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"http://www.sohu.com\"&gt;库克分享inphone xs&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt; &lt;a href=\"http://www.baidu.com\"&gt;中子星内比例&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"http://www.sohu.com\"&gt;库克分享inphone xs&lt;/a&gt; &lt;/li&gt; &lt;/ol&gt; &lt;/body&gt;&lt;/html&gt; 下载页面上无法保存的图片，浏览器按F12进入控制面板查看源代码，右边部分有图片下载地址。 超链接补充 1&lt;a herf = \"http://www.baidu.com\" target=\"_blank\"题目&lt;/a&gt; 使用target指定在新窗口中打开超链接 列表补充，样式有三种实心圆，空心圆，实心方块 123&lt;ul type=\"disc\"&gt; &lt;/ul&gt; 实心圆空心圆: circle方块: square 有序列表补充，样式：数字，字母，罗马字母 12345&lt;ol type=\"1\"&gt; &lt;/ol&gt; 数字&lt;ol type=\"a\"&gt; &lt;/ol&gt; 小写字母&lt;ol type=\"A\"&gt; &lt;/ol&gt; 大写字母&lt;ol type=\"i\"&gt; &lt;/ol&gt; 小写罗马&lt;ol type=\"I\"&gt; &lt;/ol&gt; 大写罗马 图片补充 1&lt;img src=\"\" title=\"鼠标划上去显示的文字\" alt=\"图片加载失败的时候显示的文字\" 文字格式补充 1234&lt;del&gt;给文字增加删除线&lt;/del&gt; &lt;sup&gt;把文字变成上标比如10的平方&lt;/sup&gt;&lt;u&gt;给文字增加下划线&lt;/u&gt;&lt;center&gt;文字居中&lt;/center&gt; 百度网盘页面设计 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"../img/1.png\" width=\"100%\"/&gt; &lt;p&gt; &lt;a href=\"../index.html\"&gt; &lt;img src=\"../img/3.png\" width=\"100px\"&gt; &lt;/a&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"img/1.png\" width=\"100%\"/&gt; &lt;p&gt; &lt;a href=\"one/index.html\"&gt; &lt;img src=\"img/2.png\" width=\"100px\"/&gt;one &lt;/a&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 表格制作 12345678910&lt;table&gt; 表示表格 &lt;tr&gt; 表示每一行 &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 表示一个单元格 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;表格&lt;/h3&gt; &lt;table border=\"1px\" cellspacing=\"0\"&gt; &lt;col width=\"100px\"&gt; &lt;col width=\"100px\"&gt; &lt;col width=\"100px\"&gt; &lt;tr align=\"center\"&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=\"100px\" align=\"center\"&gt;mingzi&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;44&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;33&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;55&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;66&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=\"100px\" align=\"center\"&gt;fenshu&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;&lt;/td&gt; &lt;td width=\"100px\" align=\"center\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 快速建表 6行7列 1tr*6&gt;td*7 按tab补全 td内用row/col span合并单元格。制作表格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1px\" cellspacing=\"0\"&gt; &lt;col width=\"100px\"/&gt; &lt;col width=\"100px\"/&gt; &lt;col width=\"100px\"/&gt; &lt;col width=\"100px\"/&gt; &lt;col width=\"100px\"/&gt; &lt;col width=\"100px\"/&gt; &lt;col width=\"200px\"/&gt; &lt;tr height=\"40px\" align=\"center\"&gt; &lt;td colspan=\"7\"&gt;个人简历&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\" align=\"center\"&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td rowspan=\"4\"&gt;照片&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\" align=\"center\"&gt; &lt;td&gt;学历&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;籍贯&lt;/td&gt; &lt;td colspan=\"3\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\" align=\"center\"&gt; &lt;td&gt;电话&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;政治面貌&lt;/td&gt; &lt;td colspan=\"3\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\" align=\"center\"&gt; &lt;td&gt;毕业院校&lt;/td&gt; &lt;td colspan=\"5\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\" align=\"center\"&gt; &lt;td&gt;求职意向&lt;/td&gt; &lt;td colspan=\"6\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 表格补充 1234567891011121314151617&lt;td&gt; &lt;/td&gt; 表示单元格&lt;th&gt; &lt;/th&gt; 将文字加粗居中（标题）&lt;col width=\"\"&gt; 标签可以简化为 &lt;colgroup span=\"5\" width=\"\"&gt; 将一整组的标签进行设置 表格的标准&lt;table&gt; &lt;thead&gt; 表格的页眉 &lt;/thead&gt; &lt;tbody&gt; 表格主体 &lt;/tbody&gt; &lt;tfooter&gt; 表格页脚 &lt;/tfooter&gt;&lt;/table&gt; 注释 ：ctrl shift / 1&lt;!-- --&gt; 表单 1234&lt;form&gt; &lt;input type=\"text / password.....\"&gt; input必须放在form标签内才能生效&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"http://www.baidu.com\" method=\"\"&gt; &lt;table width=\"600px\" border=\"1px\" cellspacing=\"0\"&gt; &lt;tr height=\"40px\"&gt; &lt;td rowspan=\"4\"&gt;信息&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\"&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"loginname\" id=\"\" value=\"\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\"&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"pwd\" id=\"\" value=\"\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=\"40px\"&gt; &lt;td colspan=\"2\"&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;input type=\"reset\" value=\"重置\" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;type指定类型，name赋值才能上传数据，action属性表示提交表单数据的名字，value是容器显示名字。 点击提交之后，会将数据上传到指定网站。 method属性设置数据的读取方式，get表示发送一个请求接收数据，填写的内容会出现上网址后面。不可以用于提交大量数据。 post用于发送一个请求，通常为提交数据，较为隐蔽的方式。用户不可见","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"HTML","slug":"HTML","permalink":"https://nari2021.github.io/my-blog/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://nari2021.github.io/my-blog/tags/CSS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"Python学习笔记(13)","date":"2021-05-29T02:28:33.000Z","path":"posts/f568f53a.html","text":"12345678910111213141516q = Queue(5) # 最大数5q.put('A')q.put('B')q.put('C')q.put('D')q.put('E')print(q.qsize())# q.put('F',timeout=3) # 3s 超时后会报错queue.full# q.put('F') # 如果队列满了只能等待# put有三个参数,obj,block=,timeout=# q.empty()if not q.full(): q.put('F', timeout=3)else: print('队列已满') 12345678910111213141516171819202122232425262728293031def download(q): images = ['girl.jpg', 'boy.jpg', 'man.jpg'] for image in images: print('正在下载:', image) time.sleep(0.5) q.put(image)def getfile(q): while True: try: file = q.get(timeout=5) print('&#123;&#125;保存成功!'.format(file)) except: print('完毕') breakif __name__ == '__main__': q = Queue(5) p1 = Process(target=download, args=(q,)) # 加括号传的是调用结果 p2 = Process(target=getfile, args=(q,)) p1.start() p1.join() p2.start() p2.join() print('over')","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(12)","date":"2021-05-27T02:12:51.000Z","path":"posts/ec73c47b.html","text":"time模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# time模块import timet = time.time()print(t) # 1622084492.9106774# time.sleep(3) # 传入的是秒t1 = time.time()print(t1 - t)s = time.ctime(t)# 把time.time方法的绝对时间（以秒为单位# 转化为字符串# Thu May 27 11:05:57 2021print(s)t = time.localtime(t)print(t) # 以元组形式存储# time.struct_time(tm_year=2021, tm_mon=5, tm_mday=27, tm_hour=11, tm_min=8,# tm_sec=23, tm_wday=3, tm_yday=147, tm_isdst=0)# 将元组换回时间戳tt = time.mktime(t)print(tt) # 1622085023.0 没有精度值# 元组转为字符串s = time.strftime('%Y-%m-%d %H:%M:%S')# 函数内有格式说明print(s) # 2021-05-27 11:16:11''' %Y Year with century as a decimal number. %m Month as a decimal number [01,12]. %d Day of the month as a decimal number [01,31]. %H Hour (24-hour clock) as a decimal number [00,23]. %M Minute as a decimal number [00,59]. %S Second as a decimal number [00,61]. %z Time zone offset from UTC. %a Locale's abbreviated weekday name. %A Locale's full weekday name. %b Locale's abbreviated month name. %B Locale's full month name. %c Locale's appropriate date and time representation. %I Hour (12-hour clock) as a decimal number [01,12]. %p Locale's equivalent of either AM or PM. '''s = time.strptime('2021/5/27', '%Y/%m/%d')print(s) # ptime 转为元组import datetimeprint(datetime.time.hour)# &lt;attribute 'hour' of 'datetime.time' objects&gt;print(time.localtime().tm_hour) # 11print(datetime.date.today()) # 2021-05-27timedel = datetime.timedelta(hours=2,weeks=3)# 时间差print(timedel)now = datetime.datetime.now()result = now + timedelprint(result) # 2021-05-27 13:43:37.647334 12345678910111213141516171819202122232425262728293031323334# random模块import randomran = random.random() # 0~1之间的随机小数print(ran)ran = random.randrange(1, 10, 2) # 步长2print(ran)ran = random.randint(1, 20)list1 = ['club 2 ', 'club 5', 'space 4', 'heart13']ran = random.choice(list1)# 随机选print(ran)ran = random.shuffle(list1) # 无返回值print(list1) # 随机打乱# 验证码def func(): code = '' for i in range(4): ran1 = chr(random.randint(0, 9)) ran2 = chr(random.randint(65, 90)) ran3 = chr(random.randint(97, 122)) r = random.choice([ran1, ran2, ran3]) code += r return code# chr ord ascii互转 1234567import hashlib # 加密算法模块msg = '于鹏中午一起吃饭去'md5 = hashlib.md5(msg.encode('utf-8'))# 不支持中文print(md5.hexdigest())# hexdigest取16进制表示，没有自动联想 12345qq = input('输入qq号码')if len(qq)&gt;=5 and qq[0]!='0': print('合法')else: print('不合法') 正则表达式 123456789101112131415s = '娜扎佟丽娅热巴'result = re.match('佟丽娅', s)# 默认从头匹配，如果匹配不成功返回noneprint(result)# 正则表达式,匹配字符串result = re.search('佟丽娅', s)# span为查找到的范围print(result.span()) # (2, 5)# result=s.find('佟丽娅')# print(result)print(result.group())# 提取到匹配的内容部分 groupprint(result.groups()) []表示指定范围的一个字符 1234s = '哈哈23f55216'result = re.search('[0-9][a-z]',s)print(result) # &lt;re.Match object; span=(3, 5), match='3f'&gt;# [] 表示一个范围，范围内为需要匹配的指定范围 12345678910111213s = 'ab56cd7vg42dfa8saf4a00'result = re.findall('[a-z][0-9][a-z]', s)# search只会匹配第一个# findall匹配所有print(result) # ['d7v', 'a8s']result = re.findall('[a-z][0-9]+[a-z]')# 正则验证次数# * :&gt;=0次# + :&gt;=1次# ? :0/1次# *? +? ?? : 前面三种字符的非贪婪模式，尽可能少的匹配# &#123;m,n&#125; : 规定次数# &#123;m,n&#125;？ : 非贪婪 1234567891011121314151617181920import re# qq号验证 5-11位qq = '456894562'# 开头不能为0 1-9result = re.match('^[1-9][0-9]&#123;4,10&#125;$', qq)print(result)# '.' 用于匹配除换行符之外的所有字符# '^' 用于匹配行首# '$' 用于匹配除换行符之外的行尾# 表示字母或者数字开头# [0-9a-zA-Z]username = 'admin001'result = re.match('[a-zA-Z][0-9a-zA-Z]&#123;5,&#125;', username)print(result)result = re.search('^[a-zA-Z][0-9a-zA-Z]&#123;5,&#125;$', username)print(result) 123456msg = 'aa*py ab.txt bb.py kk.png uu.py apyb.txt'# result = re.findall(r'\\w+.py\\b', msg)# ['aa*py', 'bb.py', 'uu.py'] '.'表示任意字符result = re.findall(r'\\w+\\.py\\b', msg)# 不是正则的\\b要双\\ 或者+r 不转译print(result) 123456789101112n = '1000'# 匹配数字result = re.match(r'[1-9]?\\d?$|100$', n)# 第一位1-9 ？表示非贪婪。\\d 任意数字非贪婪匹配两位￥做结尾# |100$ 表示或者100print(result)# (word|word|word) 表示或者 [word] 表示的是一个字母或者数字email = '12345649@qq.com'result = re.match(r'\\w&#123;5,20&#125;@(163|126|qq)\\.(com|cn)$', email)print(result) 123456789101112131415161718192021msg = '&lt;html&gt;&lt;h1&gt;abc&lt;/h1&gt;&lt;/html&gt;'result = re.match(r'&lt;(?P&lt;name1&gt;\\w+)&gt;&lt;(?P&lt;name2&gt;\\w+)&gt;(.+)&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;', msg)print(result)print(result.group(1))print(result.group(2))print(result.group(3))# 引用分组匹配内容# 1.number## 2. (?P&lt;name&gt;正则)# re:# match# search# findall# sub : 将匹配到的内容进行替换# re.sub('正则表达式', '想替换的内容', '替换（搜索）的字符串', count)# split 匹配到表达式的内容后切片 123456789101112131415161718192021222324phone = '15901018868'result = re.match(r'1\\d&#123;9&#125;[0-35689]$', phone)print(result)# 爬虫phone = '010-12345678'result = re.match(r'(\\d&#123;3&#125;|\\d&#123;4&#125;)-(\\d&#123;8&#125;)$', phone)# 小括号表示分组 方便group提取print(result)print(result.group(1))print(result.group(2))msg = '&lt;html&gt;abc&lt;/html&gt;'msg1 = '&lt;h1&gt;hello&lt;/h1&gt;'result = re.match(r'&lt;([\\w]+)&gt;(.+)&lt;/\\1&gt;$', msg)# \\1 代表第几个括号的引用print(result.group(1))print(result)# msg = '&lt;html&gt;&lt;h1&gt;abc&lt;/html&gt;&lt;/h1&gt;' # Nonemsg = '&lt;html&gt;&lt;h1&gt;abc&lt;/h1&gt;&lt;/html&gt;'result = re.match(r'&lt;([\\w]+)&gt;&lt;([\\w]+)&gt;(.+)&lt;/\\2&gt;&lt;/\\1&gt;$',msg)print(result) 线程进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from multiprocessing import Processfrom time import sleepimport osdef task1(): while True: sleep(1) print('任务1', os.getpid(), '---', os.getppid()) # 当前进程id # getppid 为父进程def task2(): while True: sleep(1) print('任务2', os.getpid(), '---', os.getppid())'''进程初始化class Process(): name: str daemon: bool pid: Optional[int] exitcode: Optional[int] authkey: bytes sentinel: int # TODO: set type of group to None def __init__(self, group: Any = ..., target: Optional[Callable] = ..., name: Optional[str] = ..., args: Iterable[Any] = ..., kwargs: Mapping[Any, Any] = ..., *, daemon: Optional[bool] = ...) -&gt; None: ...'''if __name__ == '__main__': # 创建进程 os.getpid() p = Process(target=task1, name='任务1') # p.run() # 不会启动进程 p1 = Process(target=task2, name='任务2') p.start() p1.start() # task1() # task2() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from multiprocessing import Processfrom time import sleepimport osdef task1(s, name): while True: sleep(s) print('任务1', os.getpid(), '---', os.getppid(), name) # 当前进程id # getppid 为父进程def task2(s, name): while True: sleep(s) print('任务2', os.getpid(), '---', os.getppid(), name)'''进程初始化class Process(): name: str daemon: bool pid: Optional[int] exitcode: Optional[int] authkey: bytes sentinel: int # TODO: set type of group to None def __init__(self, group: Any = ..., target: Optional[Callable] = ..., name: Optional[str] = ..., args: Iterable[Any] = ..., kwargs: Mapping[Any, Any] = ..., *, daemon: Optional[bool] = ...) -&gt; None: ...'''m = 1list1 = []if __name__ == '__main__': p = Process(target=task1, name='任务1', args=(1, 'aa')) p1 = Process(target=task2, name='任务2', args=(2, 'bb')) # args参数为可迭代的，传入一个元组(1,) # task中就能接到这个参数赋给sleep p.start() p1.start() number = 1 while True: global m # 由于进程独立处理的，所以不能共享变量 # 即不可变类型 number+=1 sleep(0.2) if number == 100: p.terminate() p1.terminate() break else: print('---',number)'''process = Process(target=函数名,name=进程名,args=传参）process对象methodp.start 启动进程p.run 执行任务没有启动进程terminate 终止''' 自定义 1234567891011121314151617181920class MyProcess(Process): def __init__(self, name): super(MyProcess, self).__init__() self.name = name # 重写run方法 def run(self): n = 1 while True: print('进程名字:' + self.name) print('&#123;&#125;----&gt;自定义进程,n:&#123;&#125;'.format(self.name, n)) n += 1if __name__ == '__main__': p = MyProcess('小明') p.start() p1 = MyProcess('小红') p1.start()","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(11)","date":"2021-05-25T01:43:25.000Z","path":"posts/c75e97b8.html","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 常用魔术方法# 魔术方法是在特定时刻自动触发，不需要调用# __init__ 参数至少接收一个self对象# 触发时机：初始化对象时触发# __new__# 触发时机：在实例化时触发class Person: def __init__(self): # self.name = name print('-----&gt;init') def __new__(cls, *args, **kwargs): print('------&gt;new') # new开辟一个新空间内存地址 # 实际上把系统底层的new魔术方法覆盖了 # 把系统底层的也恢复 return super().__new__(cls, *args, **kwargs) # 返回的是地址 传给init的self def __call__(self, name): print('---------&gt;call') print('执行对象得到的参数是,', name) # call魔术方法 # 触发时机，将对象当作函数调用时触发。 # 对象() 至少一个self接收对象 def __del__(self): # 析构函数 print('-----&gt;del')p = Person()p('hello') # __call__ 如果不声明会报错typeerrorprint(p) # p = Nonep1 = p # 指向同一个地址# 删除地址的引用del p1 # 删除p1对改地址的引用# import sys# sys.getrefcount() 获取调用次数# 当一块空间没有了任何引用，次数为0 12345678910111213# __str__class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return '姓名是' + self.name + '年龄' + str(self.age) # 触发时机。打印对象名的时候触发 p = Person('tom', 20)print(p) # 打印的不是地址，而是str魔术方法内的返回值 1234567891011121314151617181920212223242526272829303132333435363738class Student: # __age = 18 def __init__(self, name, age): self.__name = name self.__age = age self.__score = 59 def __str__(self): return '姓名:&#123;&#125;,年龄&#123;&#125;,分数&#123;&#125;.'.format(self.__name, self.__age, self.__score) # def getAge(self): # return self.__age # 一定要先有 getxxx @property def age(self): return self.__age # 再有set，依赖于get。函数名.setter修饰器 @age.setter def age(self, age): if 0 &lt; age &lt; 100: self.__age = age else: print('不在规定范围内')n = Student('韩梅梅', 15)n.__score = 60 # 赋值不成功n.age = 10print(n.age)print(n)# property装饰器是用于优化set方法的使用，将方法变成属性方便操作 继承 123456789101112131415161718192021class Person: def __init__(self, name): self.name = name self.age = 18 def eat(self): print(self.name + '正在吃饭') def run(self): print(self.name + '正在跑步')class Student(Person): def __init__(self, name): print('-----student init') super().__init__(name) # 调用父类init # super()表示父类class Employee(Person): pass 多继承 123456789101112131415161718192021222324# 多继承class A: def test(self): print('a')class B: def test1(self): print('B')class C(A, B): def test2(self): print('C')c = C()c.test()c.test2()import inspectprint(inspect.getmro(C)) # 返回一个元组类的继承顺序print(C.__mro__) # 打印继承顺序# python允许多继承，搜索顺序：广度优先 单例模式 singleton 1234567891011121314151617181920class Singleton: # 私有 __instance = None # 重写new def __new__(cls): print('-----&gt;__new__') if cls.__instance is None: cls.__instance = object.__new__(cls) return cls.__instance else: return cls.__instance # 保障单例s = Singleton()s1 = Singleton()print(s)print(s1) 导入模块 1234567891011121314# 导入包名 import+模块名# from 模块名 import+ 某一部分，可以只导入一个函数（*表示导入全部# 模块中需要用__all__=[]引用所有内容# 无论import还是from都会将模块内容进行加载# 如果不希望进行调用，用__name__# if __name__ = '__main__' 模块中执行# 在调用时，__name__ = 当前模块名# __name__在自己的模块内为__main__# 在别的模块通过引入方式__name__为模块名# 文件夹和包有区别# 文件夹存放非py文件，包存放py文件# 添加一个__init__.py文件，文件夹就变为包 12345678910# 包含关系# 项目》包》模块》类》函数》变量# from user import models# # u = models.User('admin', 123456)# u.show()from user.models import User# 可以直接在from后面用.导入相关对象u = User('admin', 123456) User.py模块文件 12345678910111213141516171819class User: def __init__(self, username, password): self.username = username self.password = password def login(self, username, password): if username == self.username and password == self.password: print('登陆成功') else: print('登录失败') def show(self): print(self.username, self.password)if __name__ == '__main__': pass# 只有在运行本模块才会调用以下代码，# 导入的情况不执行 12345678910111213141516171819__init__.py :# 该文件导入包的时候，系统自动调用# 作用# 1 把必须要初始化的信息放在这 因为强制调用# 2 此文件中函数，变量访问只需要通过包名.xxx即可# 3 加__all_对外暴露模块# from 模块 import * 可以使用所有内容，添加了__all__会限制部分# from 包 import * 该包内容不能访问，需要在__init__.py文件中# 定义__all__对外暴露模块，模块。。# 避免循环导入# 1 重新架构 : 工作量大# 2 把需要导入的import 放在需要导入的函数中避免# 在其他地方重复调用#","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(10)","date":"2021-05-24T02:57:26.000Z","path":"posts/de45a6f9.html","text":"123456789class Phone: brand = 'huaiwei'# 创建对象t = Phone()print(t.brand)t.brand = 'iphone'print(t.brand) 1234# 魔术方法：__名字__()def __init__(self): # 创建对象时自动调用 print('innit ----') 12345678910111213141516171819class Person: name = '张三' # def __init__(self): # self.name = '张三' # self.age = 18 # 传参 def __init__(self, name, age): self.name = name self.age = age def eat(self,food): print('今年&#123;&#125;岁，叫做&#123;&#125;,正在吃&#123;&#125;'.format(self.age, self.name,food))p = Person()p.name = '李四'p.eat() 类方法 1234567891011121314151617181920212223242526class Dog: def __init__(self, nickname): self.nickname = nickname # 动态添加的nickname属性 def run(self): # self 对象 需要对象才能调用 print('&#123;&#125;在院子里跑来跑去'.format(self.nickname)) # 类方法 # 声明方式加一个@classmethod的修饰器 @classmethod def test(cls): # cls --&gt; class 有类就能调用 print(cls) # &lt;class '__main__.Dog'&gt; # print(cls.nickname) 报错 cls.run(d)d = Dog('大黄')d.run()# d.test() 报错Dog.test()# 因为类方法只能访问类属性和类方法，基本用于# 在对象创建之前，如果需要完成一些功能的时候使用 12345678910111213141516171819202122# 私有对象 在前面加__class Person: __age = 18 def show(self): print('-------&gt;', self.__age) @classmethod def update_age(cls): cls.__age = 20 print('类方法') @classmethod def show_age(cls): print('修改后的年龄为', cls.__age)Person.update_age()Person.show_age()p = Person()p.show() 静态方法用staticmethod修饰器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person: __age = 18 def __init__(self,name): self.name = name def show(self): print('-------&gt;', self.__age) @classmethod def update_age(cls): cls.__age = 20 print('类方法') @classmethod def show_age(cls): print('修改后的年龄为', cls.__age) # 静态方法要加修饰器 @staticmethod def test(): print('------&gt;静态方法') # print(self.name) 语法错误 # print(cls.__age) 没传入cls不能直接用 print(Person.__age)Person.update_age()Person.show_age()# 静态方法调用Person.test()p = Person('张三')p.show()# 静态方法# 1 用修饰器staticmethod# 2 无需传递参数cls,self# 3 只能访问类的属性和方法，对象（实例化）无法访问# 4 加载时机和类方法一致# 类方法和静态方法不同# 1 装饰器# 2 有参数，无参数## 相同# 只能访问类的属性和方法，对象无法访问# 都可通过类名调用# 创建对象之前使用，不依赖于对象# 与普通方法不同# 1 没有装饰器# 2 普通方法要依赖对象，每个普通方法都有self# 3 只有创建对象后才能使用方法 123456789101112131415161718192021222324252627282930class Cat: type = '猫' def __init__(self, nickname, age, color): self.nickname = nickname self.age = age self.color = color def eat(self, food): print('&#123;&#125;喜欢吃&#123;&#125;'.format(self.nickname, food)) def catch_mouse(self, color, weight): print('&#123;&#125;,抓了一只&#123;&#125;kg的&#123;&#125;大老鼠'.format(self.nickname, weight, color)) def sleep(self, hour): if hour &lt; 5: print('继续睡觉') else: print('赶快起床') def show(self): print('猫的详细信息') print(self.nickname, self.age, self.color)cat1 = Cat('花花', 2, '灰色')cat1.catch_mouse('黑色',2)cat1.sleep(8)cat1.eat('小金鱼')cat1.show() 123456789101112131415161718192021222324252627# 常用魔术方法# 魔术方法是在特定时刻自动触发，不需要调用# __init__ 参数至少接收一个self对象# 触发时机：初始化对象时触发# __new__# 触发时机：在实例化时触发class Person: def __init__(self): # self.name = name print('-----&gt;init') def __new__(cls, *args, **kwargs): print('------&gt;new') # new开辟一个新空间内存地址 # 实际上把系统底层的new魔术方法覆盖了 # 把系统底层的也恢复 return super().__new__(cls, *args, **kwargs) # 返回的是地址 传给init的self def __call__(self, *args, **kwargs): print('---------&gt;call')p = Person()print(p) # p = None","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(9)","date":"2021-05-23T02:22:36.000Z","path":"posts/5de06e2a.html","text":"1234567891011121314151617181920212223242526272829303132333435363738394041# def gen():# i = 0# while i &lt; 5:# temp = yield i# print('temp:', temp)# i += 1# # return '没有任何数据'# # # g = gen()# # print(next(g))# # print(next(g))# # print(next(g))# # # g.__next__()# g.send(None)# n1 = g.send('哈哈')# # 传值给yield，yield传给temp同时执行next# # 执行一次next，程序会在yield处 执行return# # 执行下一次next，会从上一次yield处继续执行# print('n1=', n1)# n2 = g.send('呵呵')# print('n2=', n2)# # def task1(n): for i in range(n): print('第&#123;&#125;个'.format(i))def task2(n): for i in range(n): print('di&#123;&#125;ge'.format(i))task1(10)task2(5)# 线性进程 12345678910111213141516171819202122232425# 任务交替：def task1(n): for i in range(n): print('第&#123;&#125;个'.format(i)) yield Nonedef task2(n): for i in range(n): print('di&#123;&#125;ge'.format(i)) yield None# 生成器不生成任何东西# 传入生成器套入循环就可以交替进行g1 = task1(5)g2 = task2(5)while True: try: # 没有跳出条件 用try和except g1.__next__() g2.__next__() except: break 1234567891011121314151617181920212223242526# 迭代器和可迭代对象# 判断是否可迭代from collections.abc import Iterablelist1 = [1, 5, 4, 9, 8]f = isinstance(list1, Iterable)print(f)# 列表字符串等都可迭代# 生成器：g = (x + 1 for x in range(10))f = isinstance(g, Iterable)print(f) # 生成器可迭代# 迭代器是一个可以记住遍历位置的对象，# 迭代器对象从集合的第一个元素开始访问，# 直到所有元素访问完，只能前进# 可以被next不断调用访问下一个值，为迭代器Iterator# 可迭代的不一定就是迭代器比如list（不能用next调用# list----》迭代器# iter() builtinslist1 = iter(list1) # 类型转换成可迭代的迭代器print(next(list1))","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(8)","date":"2021-05-22T01:12:46.000Z","path":"posts/44fb5f6b.html","text":"文件的批量复制 12345678910111213141516171819202122232425import ossrc_path = ''target_path = ''def copy(src, target): if os.path.isdir(src) and os.path.isdir(target): filelist = os.listdir(src) for file in filelist: path = os.path.join(src, file) with open(path, 'rb') as rstream: # 只用r的话有些文件读不出来 container = rstream.read() path1 = os.path.join(target, file) with open(path1, 'wb')as wstream: wstream.write(container) else: print('复制完毕')# 调用函数copy(src_path, target_path) 复制的路径中有文件夹，使用递归。 递归中将目标路径先拼接，用os.mkdir创建子文件夹，再将拼接后的路径传入copy递归。 123456789101112131415161718192021222324252627282930313233# 复制的文件中有文件夹import ossrc_path = r'D:\\Backup\\桌面\\Python'target_path = r'D:\\Backup\\桌面\\P1'def copy(src_path, target_path): filelist = os.listdir(src_path) for file in filelist: path = os.path.join(src_path, file) if os.path.isdir(path): # 如果是文件夹 # os.chdir(path) # 进入/改变工作路径 # 递归 target_path1 = os.path.join(target_path, file) os.mkdir(target_path1) copy(path, target_path1) # 复制路径如果target的话，子文件的所有文件都复制在了target里 else: with open(path, 'rb') as rstream: container = rstream.read() path1 = os.path.join(target_path, file) with open(path1, 'wb') as wstream: wstream.write(container) else: print('复制完成')copy(src_path, target_path) 用户注册 123456789101112131415161718# 用户注册def register(): username = input('输入用户名:') password = input('输入密码:') repassword = input('再次输入密码:') if password == repassword: # 保存信息 with open(r'D:\\Backup\\桌面\\P1\\user.txt', 'a')as wstream: wstream.write('&#123;&#125; &#123;&#125;\\n'.format(username, password)) print('用户注册成功') else: print('密码不一致')# 调用register() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 图书管理系统# 文件保存功能# 用户注册def register(): username = input('输入用户名:') password = input('输入密码:') repassword = input('再次输入密码:') if password == repassword: # 保存信息 with open(r'D:\\Backup\\桌面\\P1\\user.txt', 'a')as wstream: wstream.write('&#123;&#125; &#123;&#125;\\n'.format(username, password)) print('用户注册成功') else: print('密码不一致')# 用户登录def login(): username = input('输入用户名:') password = input('输入密码:') if username and password: # 非空 with open(r'D:\\Backup\\桌面\\P1\\user.txt') as rstream: while True: user = rstream.readline() # admin 123456\\n if not user: # 如果读到空说明读到尾 print('用户名或者密码输入有误!') break input_user = '&#123;&#125; &#123;&#125;\\n'.format(username, password) if user == input_user: print('用户登陆成功') breakdef show_books(): print('-----------图书馆里的书有-----------') with open(r'D:\\Backup\\桌面\\P1\\books.txt', 'r', encoding='UTF-8') as rstream: books = rstream.readlines() for book in books: print(book)# 调用# register()# login()show_books() 123456789101112131415161718192021222324252627282930313233343536373839# 异常处理'''try:except:finally'''def func(): try: n1 = input('请输入第一个数字') n2 = input('请输入第二个数字') result = n1 + n2 print(result) except ZeroDivisionError: pass except Exception as err: print(err) # 打印原因 else: # 没有出现异常则执行 pass finally: passdef fun(): stream = None try: pass except: pass finally: if stream: stream.close()func() 生成器 12345678910111213141516171819202122232425# 生成器# 一边循环一边计算称之为生成器 不会持续占用内存# 1 通过列表推导式得到生成器# newlist = [x * 3 for x in range(10)]# print(newlist)# 只需要将推导式的方括号换成圆括号即可g = (x * 3 for x in range(10))print(type(g)) # &lt;class 'generator'&gt;# 方式1 调用__next__() 每次只能生成一个元素print(g.__next__())print(g.__next__())# 方式2 next()方法 builtins 方法print(next(g))# 此时生成器上限是10 超出返回会报异常 StopIterationwhile True: try: e = next(g) print(e) except StopIteration: print('产生完毕') break 只要函数中出现了yield关键字 就不是函数。 1234567891011121314151617181920212223# 生成器2 函数# 斐波那契数列# 函数中有yield关键字就不算为函数 为生成器def func(): n = 0 while True: n += 1 print(n) # yield n# func() # 会一直打印def fun(): n = 0 while True: n += 1 print(n) yield n # 只要加了该关键字就为生成器g = fun()print(g) # generator object 斐波那契数列 1234567891011121314151617181920def fib(length): a, b = 0, 1 n = 0 while n &lt; length: # print(b) yield b a, b = b, a + b n += 1 return '没有更多元素' # 返回值会以StopIretion的形式报错返回。g = fib(10)print(next(g))print(next(g))print(next(g))print(next(g))print(next(g))print(next(g))print(next(g))print(next(g))","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(7)","date":"2021-05-21T01:39:16.000Z","path":"posts/c36343a4.html","text":"文件操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114# # 写文件# '''# mode为w write，表示写操作# 每次都会将原来的内容清空覆盖# write(内容) 每次都会将内容清空写当前内容# writelines(iterable) 没有换行效果 自己加\\n## ***# 如果mode为‘a’表示追加 不会清空当前文件内容# '''# stream = open(r'D:\\Backup\\桌面\\Python\\test.txt', 'w')# # 打开操作是w write# r = stream.writable()# print(r)## s = '''# 你好!# 欢迎### '''## result = stream.write(s) # 写操作会覆盖掉原来的内容# print(result)# stream.write('你好呀') # 只要不释放资源还可以继续写不覆盖上一个write的内容# stream.writelines('赌神告警')# stream.writelines(['赌神告警', '赌侠刘德华', '赌圣主线程']) # 迭代可以写成列表# # 没有换行操作,但是可迭代# # writelines传入参数为可迭代的iterable# stream.close()# # 要释放资源## stream = open(r'D:\\Backup\\桌面\\Python\\test.txt', 'a')# stream.write('僵尸先生')# # 文件复制# '''# 原文件:D:\\Backup\\桌面\\Python\\test.jpg# 目标文件：D:\\Backup\\桌面\\Python\\test2.jpg## '''# stream = open(r'D:\\Backup\\桌面\\Python\\test.jpg', 'rb')# stream.close()# # 以上内容可以用下面代码代替# # 文件操作常用# with open(r'D:\\Backup\\桌面\\Python\\test.jpg', 'rb') as stream:# pass## # with 结合open使用，可以帮助自动释放资源# with open(r'D:\\Backup\\桌面\\Python\\test.jpg', 'rb') as stream:# container = stream.read() # 读文件内容# # 此处如果不缩进stream资源会给释放# with open(r'D:\\Backup\\桌面\\Python\\test2.jpg', 'wb') as wstream:# wstream.write(container)# open内要具体到文件名 如果想操作整个文件夹用os模块'''模块: xxx.py builtins.py 内置模块 内置模块不需要导入os.py'''import osprint(os.path)print(os.path.dirname(__file__)) # __file__表示当前文件# 获取当前文件路径path = os.path.dirname(__file__)# path.join() # 这里调用的是字符串的join 传入的是可迭代的列表# 要用os里面的joinresult = os.path.join(path, 'test1.jpg') # 传入参数为path,pathsprint(result) # D:/Backup/桌面/Python\\test1.jpg 斜杠方向相反没有关系# with 结合open使用，可以帮助自动释放资源with open(r'D:\\Backup\\桌面\\Python\\test.jpg', 'rb') as stream: container = stream.read() # 读文件内容 print(stream.name) file = stream.name filename = file[file.rfind('\\\\') + 1:] # 从右找 切片 # 此处如果不缩进stream资源会给释放 with open(result, 'wb') as wstream: wstream.write(container)# 判断相对路径 绝对路径r = os.path.isabs(r'D:\\Backup\\桌面\\Python\\test.jpg')print(r)r = os.path.isabs(r'..\\Python\\test.jpg')print(r)# ../表示当前文件的上级path = os.path.dirname(__file__) # 获取路径directoryprint(path)print(os.path.isabs(path))# 相对路径获取绝对路径print(os.path.abspath('test.txt'))path = os.getcwd() # 当前文件的工作目录print(path)# 将文件名和路径拆分存在一个元组里path = r'D:\\Backup\\桌面\\Python\\test.jpg'result = os.path.split(path)print(result)# 拆分拓展名之前的部分# ('D:\\\\Backup\\\\桌面\\\\Python\\\\test', '.jpg')result = os.path.splitext(path)print(result)size = os.path.getsize(path)print(size)result = os.path.join(os.getcwd(), 'file', 'test.jpg') # 可迭代参数# 'file','a' 多几个就多创建几个文件夹。print(result)# isabs isfile isdir 12345678import osdir = os.getcwd()print(dir)all = os.listdir(r'D:\\Backup\\桌面\\Python')# 返回该文件夹下所有文件和文件夹 保存在列表里print(all) 123456# 创建文件夹# 先判断是否存在if not os.path.exists(r'D:\\Backup\\桌面\\P1'): os.mkdir(r'D:\\Backup\\桌面\\P1')# 如果文件已经存在的话，无法创建# 没有返回值 123456789# 删文件os.remove(r'D:\\Backup\\桌面\\P1\\test.txt')# 删除文件夹os.rmdir(r'D:\\Backup\\桌面\\P1')# 没有返回值# 只能删除空的文件夹# 创建出来的文件.P1os.removedirs(r'D:\\Backup\\桌面\\P1') 12345678910111213# 删文件import ospath = r'D:\\Backup\\桌面\\P1'filelist = os.listdir(path)for file in filelist: path1 = os.path.join(path, file) os.remove(path1) # 把文件夹内所有文件删除else: os.rmdir(path) # 只能删除空文件夹print('删除成功') 12# 切换当前工作目录# os.chdir()","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(6)","date":"2021-05-20T02:33:51.000Z","path":"posts/da7872e5.html","text":"123456789101112import syslist1 = [1, 2, 3]list2 = list1list3 = list1print(sys.getrefcount(list1)) # 返回被引用次数del list1print(sys.getrefcount(list2)) # 返回被引用次数del list2print(sys.getrefcount(list3)) # 返回被引用次数 123456789101112131415# 闭包、嵌套def outer(): a = 100 def inner(): b = 200 print('inner') result = locals() print(locals()) # &#123;'a': 100, 'inner': &lt;function outer.&lt;locals&gt;.inner at 0x0000016C49967678&gt;, 'result': &#123;...&#125;&#125;outer() 123456789101112131415def outer(): a = 100 def inner(): # 如果要对外部变量操作 nonlocal a # 将外部变量取消局部变量 b = 200 b += a print('inner', b) # inner 300# 内部函数可以使用外部函数的变量 但是不可以修改 print(a) inner()outer() 闭包 1234567891011121314def outer(n): a = 10 def inner(): b = a + n print('内部函数:', b) return inner # 不是inner()，而是传出该函数r = outer(5)print(r)r() 装饰器 1234567891011121314151617181920212223242526# 定义装饰器,闭包def decorator(func): print('------------&gt; 1') def wrapper(): func() print('刷漆') print('铺地板') print('买家具') print('精装修') print('-------------&gt;2') return wrapper@decorator # 等价于house = decorater(house)def house(): print('毛坯房')@decoratordef xxx(): print('xxx')house() 12345678910'''装饰器的应用场景 遵循开放封闭原则，在不改变原函数的情况下 拓展函数的功能1 引入日志2 函数执行时间统计3 执行函数前预备处理4 执行函数后清理功能5 权限校验6 缓存''' 带参数的装饰器 123456789101112131415# 原函数有参数，装饰器内也要有参数。def decorator(func): def wrapper(*args,**kwargs): # 使用*args和**kwargs保证调用的时候传多少个参数都可以 func(*args,**kwargs) # 此处*为拆包 print('刷漆精修房')# 如果没有**kwargs的话，传入的是默认参数键值对的话，只能接收到键，会报错。 return wrapper@decoratordef house(address, area): print('房子地址是&#123;&#125;,是一个毛坯房...面积&#123;&#125;'.format(address, area))house('北京四合院', 20) 123@デコレータ関数を生成する関数(引数)def デコレート対象の関数(引数): 関数の中身 12345678910111213141516171819202122232425262728def outer_check(time): print('-------&gt;1') def check_time(action): print('--------&gt;3') def do_action(): if time &lt; 23: return action() else: return '对不起，您不具有该权限!' print('-------&gt;4') return do_action print('----------&gt;2') return check_time@outer_check(23)# r = outer_check(23) ----&gt; return r = check_time# check_time(play_game)传入函数# 即此时play_game = do_actiondef play_game(): return '玩游戏'print(play_game()) 递归 12345678910111213141516def test(): print('test') a()def a(): print('a') a() # 超出递归深度会报错a()'''result: [Previous line repeated 993 more times] RecursionError: maximum recursion depth exceeded while calling a Python object''' 12345678910111213141516# 1 递归要有出口# 2 每次向递归出口靠近# 1-10打印def test(i): if i == 10: print('10') # 出口 else: print(i) i += 1 test(i)test(1) 匿名函数 1234567891011121314# 匿名函数 功能十分简单，写def函数缩进等麻烦# 使用lambda只包含一个语句# 语法 lambda 参数列表:返回值表达式def test(a): return a + 1# 简化上面的函数r = lambda a: a + 1 # 要有接收print(r(4))r = lambda x, y: x + yprint(r(5, 6)) 12345678910111213141516171819202122# 使用场合def test(): print('test')def func(a, f): print('-----&gt;', a) f()func(5, test)def func1(a, f): print('-----&gt;', a) r = f(a) print(r)func1(8, lambda x: x ** 2) # 返回结果为平方# 匿名函数给f(a)赋值# 应用场景：表达式放在函数的参数位置 12345list1 = [('tom', 20), ('lily', 19), ('danel', 33)]m = max(list1, key=lambda x: x[1])print(m)# 同理min sorted ↑如果不传key，按照字母排序。 12345678class map(object): \"\"\" map(func, *iterables) --&gt; map object Make an iterator that computes the function using arguments from each of the iterables. Stops when the shortest iterable is exhausted. \"\"\"# 迭代器 1234567891011rrr = filter(lambda x: x[1] &gt; 11, list1)# 返回的是filter的一个object# 输出要转为listprint(list(rrr))ma = map(lambda x: x[0].title(), list1)print(list(ma))# 用于压缩运算r = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5, 6])print(r) 文件操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 文件操作'''文件上传保存log系统函数 open()'''# def open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)# mode# r:read# w:write# b:binary# rb,rw read binary/ write binary# rb,rw 包括了所有类型文件 图片，音乐，电影# 'r' open for reading (default)# 'w' open for writing, truncating the file first# 'x' create a new file and open it for writing# 'a' open for writing, appending to the end of the file if it exists# 'b' binary mode# 't' text mode (default)# '+' open a disk file for updating (reading and writing)# 'U' universal newline mode (deprecated)#### 此处添加r为了防止斜杠转译# stream = open(r'D:\\Backup\\桌面\\Python\\test.txt')# stream.read()# print(stream)# 这个read方法是一个抽象装饰器的函数# 读操作# open(path/filename,'rt'(默认,读文本文件))# 返回值是数据管道 stream# stream.read 读取管道中的内容# 如果文件名不对的话会报错 FileNotFoundstream = open(r'D:\\Backup\\桌面\\Python\\test.txt')# r = stream.read()# print(r) # 读出文件内容hello world# 这里会造成文件指向偏移影响后面的内容 每个文件只能读一次 会指到文件最后result = stream.readable() # 判断是否可读print(result)## while True:# line = stream.readline()# print(line, end='') # 默认换一行# if not line:# breaklines = stream.readlines() # 结果保存在列表里print(lines)# ['hello world\\n', 'hi\\n', 'happy']# 取操作for i in lines: print(i, end='') 12345#stream = open(r'D:\\Backup\\桌面\\Python\\test.jpg', 'rb')# 读图片要转为二进制rbcontainer = stream.read()print(container)","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(5)","date":"2021-05-19T01:38:56.000Z","path":"posts/f1552126.html","text":"12345678910111213141516171819202122232425262728293031323334353637# 集合 底层是用字典做的# set# 特点，没有重复，无序# 花括号内的元素不是键值对，就为set# 如果放的键值对，就是字典set1 = &#123;'zhangsan'&#125;print(type(set1))# 列表强转集合list1 = [1, 2, 3, 6, 8, 9, 9, 1, 2, 3, 4, 5]set2 = set(list1)print(set2)set3 = &#123;&#125; # 空字典print(type(set3))set4 = set() # 集合声明方法print(type(set4))# 添加元素 addset4.add('三体')set4.add('盗墓笔记')priprint(result)nt(set4)set4.add('红楼梦')print(set4)# append extend -----&gt;list# update add -----&gt;setset1.update(set4)print(set1) # 将set4 插入到set1 中，无序。print(set4)# 重复添加没有变化result = set4.add('三体') # 没有返回值print(set4) 产生验证码 123456789101112131415161718# 打印五组不重复验证码import randomcode_list = set()s = 'qwertyuiopasdfghjklzxcvbnm0123456789'while True: code = '' for i in range(4): r = random.choice(s) # 随机从某个字符串内选择一个 code += r # index = random.randint(0, len(s)-1) # code += s[index] # 将code添加到set中 code_list.add(code) # 判断长度为5 if len(code_list) == 5: breakprint(code_list) 其余方法 1234567891011121314# 移除元素 remove discard# pop按顺序弹出，但是集合没有顺序 随机删除set1 = &#123;'rbkf', '2f3t', 'kf7g', 't5li', 'k8eb'&#125;set1.remove('rbkf') # 如果不存在会报错print(set1)set1.discard('rbkf') # 如果成员不存在也不会报错# del set1 整个删除set1.clear()set1.difference() # 返回集合的差集set1.intersection() # 返回交集set1.union() # 并集# 可以用符号代替 -差集 &amp;交集 |并集 几个常用结构相互转换 1234567891011'''list ----&gt; tuple,set(长度可能会发生改变)tuple ----&gt;list,set(同上)set ----&gt; list,tupledict ---&gt; list,tuple,set key值保留，value会丢失'''# list转dictlist1 = [('a', 10), ('b', 20)]print(dict(list1)) 1234567891011121314151617# 公共方法(内置方法)'''print() input() type() len() id() delin not in is 进制转换 bin hex oct int最大值，最小值list1 = [1,2,3,4,5,6,7]result = max(list1)min()result = sum(list1) abs()sorted(xx,reverse=True) # list1.sort(self,reverse)result = chr(int) ---&gt; ASCII码转换成字符。ord() ----&gt;字符转ASCII码值。''' 列表推导式 1234567891011121314151617181920212223242526272829# 列表推导式list1 = []for i in range(1, 21): list1.append(i)print(list1)# 格式 [a for i in 可迭代的]# a为赋值变量list1 = [i for i in range(1, 21)]list1 = [i + 2 for i in range(1, 10)]# 1-100之间的偶数list1 = [i * 2 for i in range(0, 51)]list1 = [i for i in range(0, 101, 2)] # 步长为2# if判断格式# [i for i in 可迭代 if 条件]list1 = [i for i in range(0, 101) if i % 2 == 0]list2 = ['62', 'luck', '99']list3 = [word for word in list2 if word.isalpha()]# if else格式list4 = [word.title() if word.startswith('h') else word.upper() for word in list3]print(list4)# 双层for循环list5 = [(i, j) for i in range(1, 5) for j in range(3, 5)] 函数定义 1234567891011121314151617181920212223242526272829303132# 定义函数# 格式# def 函数名()# 代码## 打印五组不重复验证码import randomdef generate_code(n): code_list = set() s = 'qwertyuiopasdfghjklzxcvbnm0123456789' while True: code = '' for i in range(4): r = random.choice(s) # 随机从某个字符串内选择一个 code += r # index = random.randint(0, len(s)-1) # code += s[index] # 将code添加到set中 code_list.add(code) # 判断长度为5 if len(code_list) == n: break print(code_list)print(generate_code) # &lt;function generate_code at 0x0000028863077168&gt;# 调用函数generate_code(2) 传参函数要注意类型判断 12345678910111213# 类型一致def get_sum(a, b): # if type(a) == type(b): # s = a + b # print(s) if isinstance(a, int) and isinstance(b, int): s = a + b print(s) else: print('类型错误!')get_sum(2, 3) 形参，多个参数，可变参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 默认值参数# def 函数名(参数1,参数2=值)# 调用：无默认值必须传值，有默认值可传值可不传值# 参数的数据类型是列表libaray = ['python精通', 'MySQL', '数据分析']# 形参def add_book(bookname): libaray.append(bookname) print('成功')def show_book(books): for book in books: print(book)add_book('新概念英语')show_book(libaray)# 可变参数 *arg **kwarg# def get_sum(a, b):# r = a + b# print(r)# *arg *a都是一样的，*号是必须的def get_sum(*args): s = 0 for i in args: s += i print(s)get_sum(1, 2)get_sum(1, 3, 5, 7)a, *b, c = 1, 2, 3, 4, 5print(a, b, c)# *b [2, 3, 4]ran_list = [1, 3, 5, 4, 7, 8, 9]# get_sum(ran_list)# 传入的是元组 ([1, 3, 5, 4, 7, 8, 9],)get_sum(*ran_list) # 拆包 传参声明的时候，加星号为装包。装为列表 调用的时候，加星号为拆包。将元组拆包。","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(4)","date":"2021-05-18T01:39:06.000Z","path":"posts/e84e1067.html","text":"1 列表的添加 append 添加单个元素 +号直接连接 extend拓展。 123456789101112131415161718192021222324252627282930# # 列表的删除# # pop remove clear# list1 = ['火腿肠', '酸奶', '油条', '面包', '辣条']# list1.pop(2) # 填下标# print(list1)# # pop从后往前删减，如果不填下标，从后往前一个一个删## # remove 直接填元素# list1.remove('辣条')# print(list1)# # 删除元素# n = 0# while n &lt; len(list1):# if list1[n] == '酸奶':# list1.remove('酸奶')# else:# n += 1# print(list1)## for i in range(len(list1)):# if list1[i] == '酸奶':# list1.remove('酸奶')# i -= 1 # 重要# print(list1)## list1.clear()## print(id(list1))# list2 = []# print(id(list2)) 12345678list1 = [1, 2]list2 = list1 # 指针指向了同一个位置list2.append(8)print(list1) # list1和list2相同print(list2)list1.clear() # 指针后的所有东西删除del list2 # 删除的指针print(list1) # list1不受影响 sort默认升序。reverse默认为False，通过reverse=True变为降序。 1234567891011# 列表排序sort reverseimport randomnumbers = []for i in range(8): numbers.append(random.randint(1, 20))print(numbers)numbers.reverse() # 返回值是none，不能直接放进print，单纯的反转print(numbers)numbers.sort(reverse=True)print(numbers) 123456789101112# 将随机整数插入已排序好的数列中import randomnumbers = []for i in range(10): numbers.append(random.randint(1, 100))print(numbers)numbers.sort(reverse=True)print(numbers)numbers.append(int(input('输入一个100的整数')))numbers.sort()print(numbers) 1234# 交叉赋值# python中的简便方法a, b = b, aprint(a, b) 123456789# 冒泡排序num = [5, 1, 7, 10, 9, 2, 4, 3]for j in range(0, len(num)-1): for i in range(0, len(num) - 1 - j): if num[i] &gt; num[i + 1]: a = num[i] num[i] = num[i+1] num[i+1] = aprint(num) 1234567891011121314151617181920212223242526272829303132333435# 元组# 元组不能修改元素，只能读，不能修改。# 元组使用小括号，列表使用方括号# list 列表# tuple 元组t1 = ()print(type(t1)) # &lt;class 'tuple'&gt;t2 = ('aa')print(type(t2)) # &lt;class 'str'&gt;t2 = ('aa',)print(type(t2)) # &lt;class 'tuple'&gt;# 注意。元组内仅有一个元素时要加逗号# 下标和切片可以使用t3 = ('aa', 'bb', 4, 'cc')print(t3[2])print(t3[1:])# 逆序print(t3[::-1])# 计数print(t3.count('aa'))# 返回第一个找到的下标位置print(t3.index('aa')) # start end# 类型转换# list(tuple)# tuple(list)t3 = list(t3)print(t3)t3.append('x')t3 = tuple(t3)print(t3) 12345678910111213141516171819202122232425262728293031323334# 字典book = &#123;&#125;book['书名'] = '《三体》'book['价格'] = 20book['价格'] *= 0.8print(book)# book.pop('价格') # 放入key# print(book)# r = book.popitem() # 从后往前删除一个元素 并返回一个元组# # 若为空报错# print(book)# print(r)# 取值print(book.get('书名'))value = book['书名'] # 若空会报错book.get('书名', '默认值') # 如果没有会返回一个默认值可设置# 使用 for in遍历字典，取出的是key值for i in book: print(i) # 取出为key值# 改为# for v in book.keys()# for k in book.values()print(book.items()) # 分对dict_items([('书名', '《三体》'), ('价格', 16.0)])# for k,v in book.items():book.setdefault('出版社', '人民教育出版社')print(book)dict1 = &#123;'a': 10, 'b': 20&#125;book.update(dict1) # 字典的连接print(book)","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"Python学习笔记(3)","date":"2021-05-16T01:07:46.000Z","path":"posts/a70f86a0.html","text":"由于多次保存之后都不知道为什么被清了。所以只剩下截图了。","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"吾輩は猫である","date":"2021-05-11T14:29:02.000Z","path":"posts/49c78c96.html","text":"抜粋","tags":[]},{"title":"Python学习笔记(2)","date":"2021-05-11T00:53:43.000Z","path":"posts/7fc5b99e.html","text":"Day2 and Day3 由于Day2的笔记没有保存丢失，只剩下截图了（ Day3 位运算打印结果为int类型 位取反会产生补码 由于去了毕业旅游，day4和day3并在一起。 if 语句不用加括号，要加冒号，用缩进表示包含。 随机数函数需要引入random包。 条件2 用elif。 if else的进阶用法 用pass表示语句，可以暂时不编程。 空字符串表示false，有内容为true while循环。也是用冒号。 for循环 起始，终止，跳。 range范围为[X,Y)。1-50和为 （1,51） for i in range(3) 用于密码错误尝试三次。 for i in range(n): else: while…else同理","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"走れメロス","date":"2021-05-10T13:08:38.000Z","path":"posts/5a1d991.html","text":"新出語彙 妹婿：いもうとむこ 賢臣：けんしん 捕縛：ほばく 威厳：いげん 磔（はりつけ）とは、罪人を板や柱などに縛りつけ、槍などを用いて殺す公開処刑の刑罰のこと。磔刑（たっけい） 嗄れる：しわがれる 声がかれる ほくそ笑（え）む とは、人に隠れて笑う、人に気づかれない程度に少し笑うという意味 縄を打つ：犯人を取り押さえて―・つ 車軸：しゃじく 佳い：よい めでたい という意味をもつ 御免蒙る（ごめんこうむる）：相手の許しを得て退出する。失礼する 南無三：南無三宝の略、また失敗した際に「しまった」といった感動詞として発する。 せせら笑う：ばかにして冷ややかに笑う。あざける 胴震い：どうぶるい 寒けや恐ろしさで全身がふるえること。 おりから：折から、折柄。 ちょうどその時。 巣食うとは。 「棲み着いている」ことを表す言葉です 反社会的組織などの一般的にあまり好まれない人たちに対して使うこともできます。 独りよがり：独り善がり、自分が良いを考えていることを、他人のことをこうりょせずに、押し通そうとすること。 やんぬるかな：已矣哉の訓読み。 今となってはどうしようもない。 擡げる：もたげる 「頭を―」（目立った存在となってくる意にも） 疾風：しっぷう、はやて（疾風 どよめく：音が響き渡る まっぱだ：真っ裸 マント：披风 御復習い 悪びれずに：自分の行いを悪いことだと思うそぶりを見せない様子。 召す：めす 祭壇：さいだん 宥める：なだめる 冷静 堪える：こらえる 鞭打つ：むちうつ 怯む：ひるむ ひるまない まどろむ：微睡む 抜粋","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"日本語","slug":"日本語","permalink":"https://nari2021.github.io/my-blog/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"},{"name":"小説","slug":"小説","permalink":"https://nari2021.github.io/my-blog/tags/%E5%B0%8F%E8%AA%AC/"}]},{"title":"Python学习笔记（1）","date":"2021-05-10T02:18:05.000Z","path":"posts/db9be8e8.html","text":"1 使用单引号，双引号，三引号声明字符串，可以用于区分单双引号。 2 使用三引号输出的字符串可以保留格式输出。 3 Python中的布尔类型需要大写True False 4 重复声明中添加使用就不会警告。 5 输入数据用input（），builtins表示标准库内置函数。 6 input阻塞型函数，括号内输入提示内容。 7 使用变量存放接收到的内容 8 input接收到的数据都是string类型，无论输入的是数字还是文字。 9 不能直接使用接收到的数据进行加减需要进行类型转换。图中的+号被识别为了连接字符的符号。1000不是字符串无法连接。 10 使用和其他语言一样的类型转换int（）等。 11 注意以下区别 12 str转为int类型 前提是输入的数据没有小数。 13 True为1 False为0。 int类型转为bool。只有为0时才为False，负数正数都为True。变量为空字符串也为False。 14 print 逗号表示空格，在定义中，sep参数表示空格字符，可以设置，end属性也可以修改设置。 15 //表示整除，**表示次方。 2021.5.10 Day1","tags":[{"name":"编程","slug":"编程","permalink":"https://nari2021.github.io/my-blog/tags/%E7%BC%96%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://nari2021.github.io/my-blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Python","slug":"Python","permalink":"https://nari2021.github.io/my-blog/tags/Python/"}]},{"title":"日本語の勉強——詩（1）","date":"2021-04-05T13:44:39.000Z","path":"posts/5701c8b1.html","text":"初恋..はじめに やさしく白き手をのべて 林檎をわれにあたへしは 薄紅の秋の実に 人こひ初めしはじめなり この一節に初めて触れたのは、国語便覧の近現代名詩選を読んでいる時でした。私は多感な心で時の流れも忘れて藤村さんの素敵な詩にひたっていました。 初恋 初恋 島崎 藤村 まだあげ初めし前髪の 林檎のもとに見えしとき 前にさしたる花櫛の 花ある君と思ひけり やさしく白き手をのべて 林檎をわれにあたへしは 薄紅の秋の実に 人こひ初めしはじめなり わがこゝろなきためいきの その髪の毛にかゝるとき たのしき恋の盃を 君が情けに酌みしかな 林檎畠の樹の下に おのづからなる細道は 誰がふみそめしかたみぞと 問ひたまふこそこひしけれ 人をよわせた五七調のリズムは甘美に響きます。この詩の言葉の意味が正確に理解できませんか。おそらく理解しないまま今まで口ずさんできたでしょうね。さぁ、一行ずつ言葉の意味の解説を試みをしてみましょう。 鑑賞 まだあげ初めし前髪の 訳：まだ結い上げたばかりのあなたの前髪。 「髪を結い上げる」とは、明治時代のころ、少女が12、3歳頃になると、「もう子供でもない、成人の女性になった」という変化を示す印である。 林檎のもとに見えしとき 訳：林檎の木の下に君の姿が見えた。 「見えし」とは、動詞の連用形に過去の助動詞「き」の連体形を接続するものです。「見えし」は「見えた」の意味です。 前にさしたる花櫛の 訳：前髪のさしている花櫛は。 「花櫛」とは、造花で飾った櫛、主に少女用。「さしたる」とは、「さす」の連用形「さし」に完了・存続の意味を持つ「たり」助動詞の連体形を接続するものです。 花ある君と思ひけり 訳：君が花のように美しいと思った。 「思ひけり」とは、「思ふ」の連用形「思ひ」に過去の助動詞「けり」の終止形を接続するものです。「思ひけり」は「思った」の意味です。 やさしく白き手をのべて 訳：あなたは、やさしく白い手をのばして。 「白き」とは、「白し」の連体形です。 林檎をわれにあたへしは 訳：私に林檎をくれました。 「われ」は「我」と書きます。「あたへし」とは、ハ行下二段活用の動詞「与ふ」の連用形「与へ」に「し」を接続するものです。現代語の「与える」とちょっと違いがあります。 薄紅の秋の実に 訳：（もらった林檎は）、薄紅の秋の実です。 人こひ初めしはじめなり 訳：わたしは、初めてあなたとの恋に落ちているですよ。 「こひ」とは、「恋」です。「なり」は古典にて用いられる判断を下す助動詞です。「なり」は「です」の意味です。 わたしたちも思う人から贈り物をもらった時、その贈り物を本人の化身のように思って大切にしているでしょう。少年は、少女をくれた林檎を、少女であるかのように恋心を抱いています。 わがこゝろなきためいきの 訳：わたしがおもわずため息をもらした。 「こころなき」とは、「おもわず」の意味です。無意識に、あるいは知らず知らずのうちに。 その髪の毛にかゝるとき 訳：あなたの髪の毛にかかっている時。 たのしき恋の盃を 訳：楽しい恋の盃を。 「たのしき」とは、「楽し」の連体形です。 君が情けに酌みしかな 訳：わたしは、恋の盃を君と情け深いに酌みかわしているかな。 この句は譬えです。盃から「酌みし」という言葉が導かれています。 林檎畠の樹の下に 訳：林檎畠の樹の下に。 おのづからなる細道は 訳：（わたしたちがここに通って歩き踏み固めた）おのずからなる細道は。 林檎畠に自然にできた細道は、少年と少女は、いつも同じ道を通い、数え切れないほど会っているのでしょう。 誰がふみそめしかたみぞと 訳：「誰がこの道を踏み固めたのでしょう」と。 問ひたまふこそこひしけれ 訳：あなたは（「誰がこの道を踏み固めたのでしょう」と）尋ねる、いと愛おしく思うのです。 「あのね、林檎の中にこの細く続いてる道は、誰が作ったのかな」ーー少女が少年に訪ねます。少年は彼女を愛おしく思うのですよね。 後書き出典・引用・参考文献： [1]若菜集 [2]総合国語便覧 [3]Yahoo！知恵袋 [4]ジャパンウィキペディア","tags":[{"name":"日本語","slug":"日本語","permalink":"https://nari2021.github.io/my-blog/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"},{"name":"詩","slug":"詩","permalink":"https://nari2021.github.io/my-blog/tags/%E8%A9%A9/"},{"name":"鑑賞","slug":"鑑賞","permalink":"https://nari2021.github.io/my-blog/tags/%E9%91%91%E8%B3%9E/"}]},{"title":"开发日志1.1","date":"2021-02-19T08:11:40.000Z","path":"posts/a292b236.html","text":"开发日志1.1修复了如下bug 贴图不正确现在赞赏码可以正确显示了（再也不是别人的了 评论功能取消了原有的disqus，改为使用valine插件。现在评论可以不需要使用小飞机了。 左侧菜单修复了bulletin board不能正确指向url地址。现在可以正确指向categories属性为开发日志的文章了。但是这样会导致两个标签同时被选中，所以我决定暂时移除此功能，会在后续版本中改进。 摘要修复了原本文章摘要会弹出meting等代码的乱码，现在可以正确显示了。 路径改变由原本指向nari2021.github.io，即使用的仓库名是nari2021.github.io改为了my-blog。此操作需要在多处配置文件里面进行修改，是个雷区。 后续改进方向添加音乐功能，友链，图片大小设置，各处文章的超链接进行衔接（后续可能会更新连载系列的文，涉及到目录等功能会考虑使用Python等语言进行一键操作，待学习），使用手机等快速发博客功能，而不是在电脑使用typora编辑markdown文件还要考虑语法，主页的背景设置，转场设置等功能。 因为indigo这个模板主题有很多功能没有包含进来，后续的开发可能会遇到很多问题，敬请期待。 非常感谢你能读到这里！！","tags":[{"name":"开发日志","slug":"开发日志","permalink":"https://nari2021.github.io/my-blog/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"}]},{"title":"开发日志1.0","date":"2021-02-18T13:00:13.000Z","path":"posts/d59582a0.html","text":"开发日志1.0历经数小时，经过不断地尝试和实践，终于让这个博客有了自己的雏形，以下记录的是该博客已经实现好的功能和实现过程中的雷区。 博客的搭建主要参考教程是bilibili一个up主的视频(单击此处即可进入)。 博客选择部署在GitHub上面，gitee也可以，而且访问速度会比GitHub快很多，当完成了以上步骤就可以进行主题等操作。 主题的设置本博客采用的主题是indigo主题，在GitHub上可以进行下载。并且按照教程进行安装即可，网上的配置方式很多，可以采用 1npm install hexo-xxx 上面这个命令格式安装自己想要的插件，比如音乐播放，live2d等。具体可以参考这篇文章，里面有一些比较常用的插件。 如果按照上诉步骤弄完，主要是主题的切换，将根目录下的_config.yml 文件中 123 theme: landscapechange to theme: xxxx 然后在根目录下执行启动命令报错的话。 1hexo s 因为我遇到了这样的坑，且indigo主题的作者已经不再维护这个项目了。在GitHub的issue里面可以看到类似的问题出现，根据描述疑似是win10的个例会掉坑。最后我找到的解决方案是，直接把别人的代码拷贝下来修改yml文件的配置即可。（因为咱也不是很懂具体的内部原理 实现的一些功能包含了博客基本的功能。 个人主页 ↑这就是大概实现的一个雏形啦~ 里面的文章是测试用的文章。具体的一些小功能例如页面的自动收缩，就不详细说了，具体参照indigo的yml文件说明文档。 左侧的菜单栏介绍从上往下分别就是 主页这个就不用多说了吧！ Archives这个的功能是按照日期查看我的博客。 Tags这个的功能是按照标签对博客进行筛选。以后我写的文章里面都会认真进行分类的！ Categories这个的功能是按照分类对博客进行筛选。比如学习类，编程类，生活类。 bulletin board这个就是公告栏啦。原计划是定向到 source/categories/..目标文件夹下面的一个分类，这样点击这个菜单选项就可以直接定向到有关于开发日志和公告类的博客了。（但是目前好像出了的差错，计划在后续过程中修复 GitHub点击后会跳转到我部署在GitHub上的代码链接。 Twitter什么？你想点进来？你不对劲。目前不开放此功能！ 一些小功能评论系统使用的是框架自带的disqus。配置很简单只需要将其属性改成true即可。但是缺点也很明显，首先加载速度很慢，可能需要小飞机的支持。 如图所示。在文章最底下，可能需要等待一段时间加载。如果加载不出来，点击Reload稍等即可。 该插件是第三方的应用，所以需要Google/FB/小蓝鸟等账号的登录，需要小飞机。 评论之后的结果就会像下图一样。 打赏功能如果觉得对你有帮助的话！！！！！！！！！看到文末的小圆圈了吗（ 琐碎功能包含了访客数统计(修改配置文件)，目录导航，文章分享，站内搜索，单篇文章访问数量等功能。 我学到了什么引用一句谚语：石の上にも三年。有志者事竟成。 在教程的帮助下，虽然可以很快的以一种很简单的方式，跳过了其原理搭建出一个自己的blog，不过在此期间是有很多不通顺的地方的。正是这些地方能学习到很多东西，比如markdown文件的语法，yml文件的语法，html文件的语法，各项配置，导入，部署。只有真正做过一次才能体会到最后成功的喜悦。 最后这算是我的第一篇文章，可能会有很多没做好的地方。会在未来很长的一段时间内，不断地学习相关知识并优化该网站。 文章的数量应该也会随着时间慢慢堆积。我会在这里存放我的学习、生活、社交、对事物的思考以及一些琐碎的文章，有助于未来的我，在回首今天写下这第一篇文章时，不忘当初的初心。 非常感谢你能够阅读到这里！！！！！","tags":[{"name":"开发日志","slug":"开发日志","permalink":"https://nari2021.github.io/my-blog/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"}]}]